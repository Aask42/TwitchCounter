name: Deploy to AWS

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging
          - cleanup
          - validate

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v2
      
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v1
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ secrets.AWS_REGION || 'us-east-1' }}
        
    - name: Set up environment variables
      run: |
        echo "INSTANCE_ID=${{ secrets.INSTANCE_ID }}" >> $GITHUB_ENV
        echo "PUBLIC_DNS=${{ secrets.PUBLIC_DNS }}" >> $GITHUB_ENV
        
    - name: Validate deployment setup
      if: github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'validate'
      run: |
        echo "Running validation of deployment setup..."
        
        # Check AWS credentials
        echo "Checking AWS credentials..."
        aws sts get-caller-identity
        
        # Check if key pair exists
        echo "Checking for existing key pair..."
        KEY_PAIRS=$(aws ec2 describe-key-pairs --query "KeyPairs[?KeyName=='TwitchCounterKey'].KeyName" --output text)
        KEY_EXISTS=$(if [ -n "$KEY_PAIRS" ]; then echo "true"; else echo "false"; fi)
        echo "Key pair exists: $KEY_EXISTS"
        
        if [ "$KEY_EXISTS" = "true" ]; then
          echo "Key pair TwitchCounterKey exists."
        else
          echo "Key pair TwitchCounterKey does not exist."
        fi
        
        # Check for existing security groups
        echo "Checking for existing security groups..."
        aws ec2 describe-security-groups --filters "Name=group-name,Values=TwitchCounterSG*"
        
        # Check for existing instances
        echo "Checking for existing instances..."
        aws ec2 describe-instances --filters "Name=tag:Name,Values=TwitchCounter" --query 'Reservations[*].Instances[*].[InstanceId,State.Name]' --output table
        
        echo "Validation completed. This is a dry run, no resources were created or modified."
        exit 0
        
    - name: Clean up old AWS resources
      if: github.event_name != 'workflow_dispatch' || github.event.inputs.environment != 'validate'
      run: |
        chmod +x ./cleanup_aws.sh
        # Run cleanup with force flag if explicitly requested via workflow_dispatch
        if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ "${{ github.event.inputs.environment }}" = "cleanup" ]; then
          echo "Running forced cleanup..."
          ./cleanup_aws.sh --force
        else
          # Otherwise just clean up instances older than 7 days
          echo "Running standard cleanup..."
          ./cleanup_aws.sh
        fi
        
    - name: Check if instance exists
      id: check_instance
      run: |
        if [ -z "${{ secrets.INSTANCE_ID }}" ]; then
          echo "::set-output name=exists::false"
        else
          INSTANCE_STATE=$(aws ec2 describe-instances --instance-ids ${{ secrets.INSTANCE_ID }} --query 'Reservations[0].Instances[0].State.Name' --output text 2>/dev/null || echo "terminated")
          if [ "$INSTANCE_STATE" = "running" ]; then
            echo "::set-output name=exists::true"
          else
            echo "::set-output name=exists::false"
          fi
        fi
        
    - name: Create EC2 instance if needed
      if: steps.check_instance.outputs.exists != 'true' && (github.event_name != 'workflow_dispatch' || github.event.inputs.environment != 'validate')
      run: |
        # Check if key pair exists and handle accordingly
        echo "Checking if key pair exists..."
        KEY_PAIRS=$(aws ec2 describe-key-pairs --query "KeyPairs[?KeyName=='TwitchCounterKey'].KeyName" --output text)
        KEY_EXISTS=$(if [ -n "$KEY_PAIRS" ]; then echo "true"; else echo "false"; fi)
        echo "Key pair exists: $KEY_EXISTS"
        
        if [ "$KEY_EXISTS" = "true" ]; then
          echo "Key pair TwitchCounterKey already exists. Using existing key pair."
          # If we have the key material in secrets, save it to a file
          if [ -n "${{ secrets.EC2_SSH_KEY }}" ]; then
            echo "${{ secrets.EC2_SSH_KEY }}" > TwitchCounterKey.pem
            chmod 400 TwitchCounterKey.pem
          else
            echo "::warning::Key pair exists but we don't have the key material. You may need to delete the key pair or provide the key material as a secret."
            # Create a new key pair with a different name
            TIMESTAMP=$(date +%s)
            aws ec2 create-key-pair --key-name "TwitchCounterKey-$TIMESTAMP" --query 'KeyMaterial' --output text > TwitchCounterKey.pem
            chmod 400 TwitchCounterKey.pem
            echo "Created new key pair: TwitchCounterKey-$TIMESTAMP"
            KEY_NAME="TwitchCounterKey-$TIMESTAMP"
          fi
        else
          # Create key pair
          aws ec2 create-key-pair --key-name TwitchCounterKey --query 'KeyMaterial' --output text > TwitchCounterKey.pem
          chmod 400 TwitchCounterKey.pem
          KEY_NAME="TwitchCounterKey"
        fi
        
        # Check if security group exists and handle accordingly
        echo "Checking if security group exists..."
        SG_IDS=$(aws ec2 describe-security-groups --query "SecurityGroups[?GroupName=='TwitchCounterSG'].GroupId" --output text)
        
        if [ -n "$SG_IDS" ]; then
          echo "Security group TwitchCounterSG already exists. Using existing security group."
          SG_ID=$(echo $SG_IDS | awk '{print $1}')
          echo "Using security group: $SG_ID"
        else
          # Create security group
          echo "Creating new security group..."
          SG_ID=$(aws ec2 create-security-group --group-name TwitchCounterSG --description "Security group for Twitch Counter application" --query 'GroupId' --output text)
          echo "Created security group: $SG_ID"
          
          # Add rules to security group
          echo "Adding rules to security group..."
          aws ec2 authorize-security-group-ingress --group-id $SG_ID --protocol tcp --port 22 --cidr 0.0.0.0/0
          aws ec2 authorize-security-group-ingress --group-id $SG_ID --protocol tcp --port 80 --cidr 0.0.0.0/0
          aws ec2 authorize-security-group-ingress --group-id $SG_ID --protocol tcp --port 443 --cidr 0.0.0.0/0
          aws ec2 authorize-security-group-ingress --group-id $SG_ID --protocol tcp --port 8080 --cidr 0.0.0.0/0
        fi
        
        # Get the latest Amazon Linux 2023 AMI ID
        
        # Get the latest Amazon Linux 2023 AMI ID
        AMI_ID=$(aws ec2 describe-images --owners amazon --filters "Name=name,Values=al2023-ami-2023*x86_64" "Name=state,Values=available" --query "sort_by(Images, &CreationDate)[-1].ImageId" --output text)
        
        # Launch instance
        INSTANCE_ID=$(aws ec2 run-instances \
          --image-id $AMI_ID \
          --count 1 \
          --instance-type t2.micro \
          --key-name "${KEY_NAME:-TwitchCounterKey}" \
          --security-group-ids $SG_ID \
          --tag-specifications 'ResourceType=instance,Tags=[{Key=Name,Value=TwitchCounter}]' \
          --query 'Instances[0].InstanceId' \
          --output text)
        
        echo "INSTANCE_ID=$INSTANCE_ID" >> $GITHUB_ENV
        
        # Wait for instance to be running
        aws ec2 wait instance-running --instance-ids $INSTANCE_ID
        
        # Get public DNS name
        PUBLIC_DNS=$(aws ec2 describe-instances --instance-ids $INSTANCE_ID --query 'Reservations[0].Instances[0].PublicDnsName' --output text)
        PUBLIC_IP=$(aws ec2 describe-instances --instance-ids $INSTANCE_ID --query 'Reservations[0].Instances[0].PublicIpAddress' --output text)
        
        echo "PUBLIC_DNS=$PUBLIC_DNS" >> $GITHUB_ENV
        echo "PUBLIC_IP=$PUBLIC_IP" >> $GITHUB_ENV
        
        # Save instance info to GitHub secrets
        # Note: This requires additional setup with GitHub API tokens
        echo "::warning::New instance created. Please add these secrets to your GitHub repository:"
        echo "::warning::INSTANCE_ID: $INSTANCE_ID"
        echo "::warning::PUBLIC_DNS: $PUBLIC_DNS"
        
        # Wait for SSH to be available with timeout
        echo "Waiting for SSH to become available..."
        TIMEOUT=300  # 5 minutes timeout
        START_TIME=$(date +%s)
        
        while true; do
          # Check if SSH is available
          if nc -z -w 5 $PUBLIC_DNS 22; then
            echo "SSH is now available!"
            break
          fi
          
          # Check if we've timed out
          CURRENT_TIME=$(date +%s)
          ELAPSED_TIME=$((CURRENT_TIME - START_TIME))
          if [ $ELAPSED_TIME -gt $TIMEOUT ]; then
            echo "::warning::Timed out waiting for SSH to become available after $TIMEOUT seconds."
            echo "::warning::This could be due to security group rules, instance initialization, or network issues."
            echo "::warning::Will attempt to continue anyway, but SSH operations may fail."
            break
          fi
          
          # Print status update every 30 seconds
          if [ $((ELAPSED_TIME % 30)) -eq 0 ]; then
            echo "Still waiting for SSH... ($ELAPSED_TIME seconds elapsed, timeout at $TIMEOUT seconds)"
            echo "Checking instance status..."
            aws ec2 describe-instances --instance-ids $INSTANCE_ID --query 'Reservations[0].Instances[0].State.Name' --output text
            echo "Testing connection to $PUBLIC_DNS:22..."
            nc -v -z -w 5 $PUBLIC_DNS 22 || echo "Connection failed"
          fi
          
          sleep 5
        done
        
        # Add the host key to known_hosts
        mkdir -p ~/.ssh
        ssh-keyscan -H $PUBLIC_DNS >> ~/.ssh/known_hosts
        
    - name: Save key to file if using existing instance
      if: steps.check_instance.outputs.exists == 'true' && (github.event_name != 'workflow_dispatch' || github.event.inputs.environment != 'validate')
      run: |
        # Only create the key file if we're using an existing instance
        # For new instances, the key file was already created in the previous step
        echo "${{ secrets.EC2_SSH_KEY }}" > TwitchCounterKey.pem
        chmod 400 TwitchCounterKey.pem
        
    - name: Create setup script
      if: github.event_name != 'workflow_dispatch' || github.event.inputs.environment != 'validate'
      run: |
        cat > setup.sh << 'EOF'
        #!/bin/bash

        # Update system
        sudo yum update -y

        # Install Docker
        sudo yum install -y docker
        sudo systemctl start docker
        sudo systemctl enable docker
        sudo usermod -aG docker ec2-user

        # Install Docker Compose
        sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
        sudo chmod +x /usr/local/bin/docker-compose

        # Install Nginx
        sudo yum install -y nginx
        sudo systemctl start nginx
        sudo systemctl enable nginx

        # Create DDNS update script (instead of ddclient)
        cat > /home/ec2-user/update_ddns.sh << 'EOFDDNS'
        #!/bin/bash

        # Namecheap DDNS update script
        DOMAIN="DOMAIN_PLACEHOLDER"
        PASSWORD="PASSWORD_PLACEHOLDER"
        HOST="@"
        IP=$(curl -s https://checkip.amazonaws.com)

        # Update DDNS record
        curl -s "https://dynamicdns.park-your-domain.com/update?host=$HOST&domain=$DOMAIN&password=$PASSWORD&ip=$IP"

        echo "DDNS updated for $DOMAIN with IP $IP"
        EOFDDNS

        chmod +x /home/ec2-user/update_ddns.sh

        # Set up cron job for DDNS updates
        (crontab -l 2>/dev/null; echo "*/10 * * * * /home/ec2-user/update_ddns.sh") | crontab -

        # Clone the repository
        git clone https://github.com/Aask42/TwitchCounter.git /home/ec2-user/TwitchCounter
        cd /home/ec2-user/TwitchCounter

        # Create .env file
        cp .env.example .env

        # Create Nginx configuration
        sudo tee /etc/nginx/conf.d/twitch-counter.conf > /dev/null << 'EOFNGINX'
        server {
            listen 80;
            server_name DOMAIN_PLACEHOLDER;

            location / {
                proxy_pass http://localhost:8080;
                proxy_set_header Host $host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto $scheme;
            }
        }
        EOFNGINX

        # Test and reload Nginx
        sudo nginx -t
        sudo systemctl reload nginx

        echo "Setup completed!"
        EOF
        
        # Replace placeholders with actual values
        sed -i "s/DOMAIN_PLACEHOLDER/${{ secrets.NAMECHEAP_DOMAIN }}/g" setup.sh
        
    - name: Upload and run setup script
      if: github.event_name != 'workflow_dispatch' || github.event.inputs.environment != 'validate'
      run: |
        # Function to retry SSH commands with timeout
        function retry_ssh {
          local host=$1
          local command=$2
          local max_attempts=5
          local timeout=60
          local attempt=1
          
          while [ $attempt -le $max_attempts ]; do
            echo "SSH attempt $attempt of $max_attempts..."
            if timeout $timeout ssh -i TwitchCounterKey.pem -o StrictHostKeyChecking=no -o ConnectTimeout=10 ec2-user@$host "$command"; then
              echo "SSH command succeeded!"
              return 0
            fi
            echo "SSH attempt failed. Waiting before retry..."
            sleep 10
            attempt=$((attempt + 1))
          done
          
          echo "::error::Failed to execute SSH command after $max_attempts attempts."
          return 1
        }
        
        if [ "${{ steps.check_instance.outputs.exists }}" != "true" ]; then
          # For new instance
          echo "Uploading setup script to new instance..."
          for i in {1..5}; do
            echo "SCP attempt $i of 5..."
            if scp -i TwitchCounterKey.pem -o StrictHostKeyChecking=no -o ConnectTimeout=10 setup.sh ec2-user@$PUBLIC_DNS:~/setup.sh; then
              echo "SCP succeeded!"
              break
            fi
            echo "SCP failed. Waiting before retry..."
            sleep 10
            if [ $i -eq 5 ]; then
              echo "::warning::Failed to upload setup script after 5 attempts. Will try to create it directly via SSH."
            fi
          done
          
          echo "Running setup script on new instance..."
          retry_ssh $PUBLIC_DNS "chmod +x ~/setup.sh && ~/setup.sh"
        else
          # For existing instance
          echo "Uploading setup script to existing instance..."
          for i in {1..5}; do
            echo "SCP attempt $i of 5..."
            if scp -i TwitchCounterKey.pem -o StrictHostKeyChecking=no -o ConnectTimeout=10 setup.sh ec2-user@${{ secrets.PUBLIC_DNS }}:~/setup.sh; then
              echo "SCP succeeded!"
              break
            fi
            echo "SCP failed. Waiting before retry..."
            sleep 10
            if [ $i -eq 5 ]; then
              echo "::warning::Failed to upload setup script after 5 attempts. Will try to create it directly via SSH."
            fi
          done
          
          echo "Running setup script on existing instance..."
          retry_ssh ${{ secrets.PUBLIC_DNS }} "chmod +x ~/setup.sh && ~/setup.sh"
        fi
        
    - name: Configure application
      if: github.event_name != 'workflow_dispatch' || github.event.inputs.environment != 'validate'
      run: |
        TARGET_DNS="${{ secrets.PUBLIC_DNS }}"
        if [ -z "$TARGET_DNS" ]; then
          TARGET_DNS="$PUBLIC_DNS"
        fi
        
        # Create configuration script
        cat > configure.sh << 'EOF'
        #!/bin/bash
        
        # Update .env file
        cd /home/ec2-user/TwitchCounter
        sed -i "s/TWITCH_CHANNEL=.*/TWITCH_CHANNEL=skittishandbus/g" .env
        sed -i "s/TARGET_WORDS=.*/TARGET_WORDS=fuck,shit,damn/g" .env
        
        # Update Nginx configuration
        sudo sed -i "s/DOMAIN_PLACEHOLDER/DOMAIN_VALUE/g" /etc/nginx/conf.d/twitch-counter.conf
        sudo nginx -t
        sudo systemctl reload nginx
        
        # Update DDNS script
        sudo sed -i "s/DOMAIN_PLACEHOLDER/DOMAIN_VALUE/g" /home/ec2-user/update_ddns.sh
        sudo sed -i "s/PASSWORD_PLACEHOLDER/PASSWORD_VALUE/g" /home/ec2-user/update_ddns.sh
        
        # Run DDNS update script
        /home/ec2-user/update_ddns.sh
        
        # Start the application
        cd /home/ec2-user/TwitchCounter
        docker-compose up -d
        
        echo "Configuration completed!"
        EOF
        
        # Replace placeholders
        sed -i "s/DOMAIN_VALUE/${{ secrets.NAMECHEAP_DOMAIN }}/g" configure.sh
        sed -i "s/PASSWORD_VALUE/${{ secrets.NAMECHEAP_DDNS_PASSWORD }}/g" configure.sh
        
        # Upload and run configuration script
        echo "Uploading configuration script..."
        for i in {1..5}; do
          echo "SCP attempt $i of 5..."
          if scp -i TwitchCounterKey.pem -o StrictHostKeyChecking=no -o ConnectTimeout=10 configure.sh ec2-user@$TARGET_DNS:~/configure.sh; then
            echo "SCP succeeded!"
            break
          fi
          echo "SCP failed. Waiting before retry..."
          sleep 10
          if [ $i -eq 5 ]; then
            echo "::warning::Failed to upload configuration script after 5 attempts."
          fi
        done
        
        echo "Running configuration script..."
        for i in {1..5}; do
          echo "SSH attempt $i of 5..."
          if timeout 120 ssh -i TwitchCounterKey.pem -o StrictHostKeyChecking=no -o ConnectTimeout=10 ec2-user@$TARGET_DNS "chmod +x ~/configure.sh && sudo ~/configure.sh"; then
            echo "Configuration script executed successfully!"
            break
          fi
          echo "SSH failed. Waiting before retry..."
          sleep 10
          if [ $i -eq 5 ]; then
            echo "::warning::Failed to execute configuration script after 5 attempts."
          fi
        done
        
    - name: Output deployment information
      if: github.event_name != 'workflow_dispatch' || github.event.inputs.environment != 'validate'
      run: |
        TARGET_DNS="${{ secrets.PUBLIC_DNS }}"
        if [ -z "$TARGET_DNS" ]; then
          TARGET_DNS="$PUBLIC_DNS"
        fi
        
        echo "::notice::Deployment completed successfully!"
        echo "::notice::Application is running at: http://${{ secrets.NAMECHEAP_DOMAIN }}"
        echo "::notice::Server address: $TARGET_DNS"
        
    - name: Monitor and report deployment status
      if: always()
      run: |
        echo "Deployment Status Report"
        echo "======================="
        
        # Check if we're in validation mode
        if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ "${{ github.event.inputs.environment }}" = "validate" ]; then
          echo "Validation mode was used - no actual deployment was performed."
          exit 0
        fi
        
        # Check if instance exists
        if [ -n "${{ env.INSTANCE_ID }}" ] || [ -n "${{ secrets.INSTANCE_ID }}" ]; then
          INSTANCE_ID="${{ env.INSTANCE_ID }}${{ secrets.INSTANCE_ID }}"
          INSTANCE_STATE=$(aws ec2 describe-instances --instance-ids $INSTANCE_ID --query 'Reservations[0].Instances[0].State.Name' --output text 2>/dev/null || echo "not found")
          echo "Instance ID: $INSTANCE_ID"
          echo "Instance State: $INSTANCE_STATE"
        else
          echo "No instance ID found. Deployment may have failed."
        fi
        
        # Check key pair status
        KEY_PAIRS=$(aws ec2 describe-key-pairs --query "KeyPairs[?starts_with(KeyName, 'TwitchCounterKey')].KeyName" --output text)
        if [ -n "$KEY_PAIRS" ]; then
          echo "Key pairs found: $KEY_PAIRS"
        else
          echo "No key pairs found with name starting with 'TwitchCounterKey'."
        fi
        
        # Check security groups
        SG_IDS=$(aws ec2 describe-security-groups --query "SecurityGroups[?GroupName=='TwitchCounterSG'].GroupId" --output text)
        if [ -n "$SG_IDS" ]; then
          echo "Security groups found: $SG_IDS"
        else
          echo "No security groups found with name 'TwitchCounterSG'."
        fi
        
        echo "======================="
        echo "If you encountered any issues, please run the workflow with the 'validate' environment to check your setup."